name: SecureSDLC SCA
run-name: "[SecureSDLC SCA] Ref:${{ github.ref_name }} Event:${{ github.event_name }}"

on:
  workflow_dispatch: {}
  workflow_call:
    secrets:
      SEMGREP_APP_URL:
        required: true
      SEMGREP_APP_TOKEN:
        required: true
      SDLC_SLACK_NOTIFICATIONS:
        required: false
  pull_request: {} 
  # pull_request_target: {} # Gives workflows excessive permissions. Not wanted.
  push: # Used for local testing.
    branches:
      - '**' 

jobs:
  securesdlc-visibility-check:
    name: Repo visibility check
    continue-on-error: true 
    runs-on: ubuntu-24.04
    permissions:
      contents: read # for actions/checkout to fetch code
    env:
      GITHUB_REF_NAME: ${{ github.ref_name }}
      GITHUB_DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
      GITHUB_EVENT_NAME: ${{ github.event_name }}
    outputs:
      visibility: ${{ steps.get_visibility.outputs.visibility }}
    steps:
      - name: Init
        run: |
          echo $GITHUB_REF_NAME
          echo $GITHUB_DEFAULT_BRANCH
          echo $GITHUB_EVENT_NAME

      - name: Get Repository Visibility
        id: get_visibility
        uses: actions/github-script@v6
        with:
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            // The 'visibility' field can be 'public', 'private', or 'internal'
            const visibility = repo.visibility;
            console.log(`Repository visibility: ${visibility}`);
            core.setOutput('visibility', visibility);

      - name: Display Visibility
        run: echo "Repository visibility is ${{ steps.get_visibility.outputs.visibility }}"

  semgrep:
    name: SecureSDLC SCA
    continue-on-error: true     
    needs: [securesdlc-visibility-check]    
    if: ${{ github.actor != 'dependabot[bot]' }}
    runs-on: ubuntu-24.04
    container:
      image: ghcr.io/nautilus-wraith/docker-semgrep/semgrep:1.124.0
    permissions:
      contents: read # for actions/checkout to fetch code
      security-events: write # for github/codeql-action/upload-sarif to upload SARIF results
      actions: read # only required for a private repository by github/codeql-action/upload-sarif to get the Action run status
    env:
      SEMGREP_APP_URL: ${{ secrets.SEMGREP_APP_URL }}
      SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
      LAST_COMMITTER: ${{ github.actor }}
      GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Identify the last Committer
        run: |
          # Shortening last committer. Some committers are bots with long names or not permitted chars
          LAST_COMMITTER_SHORTENED=$(echo "${LAST_COMMITTER:0:26}")
          echo "LAST_COMMITTER_SHORTENED=$LAST_COMMITTER_SHORTENED" >> "$GITHUB_ENV"
      - name: Generate Semgrep Tags
        run: |
          echo "Overwriting .semgrepconfig.yml"
          cat <<EOF > .semgrepconfig.yml
          tags:
            - GitHub Action
            - Last Committer $LAST_COMMITTER_SHORTENED
            - $GITHUB_REPOSITORY_OWNER
          EOF

      - name: Run Semgrep SCA scan # suppressed output
        timeout-minutes: 10
        run: semgrep ci --supply-chain --metrics off --no-suppress-errors --use-git-ignore --sarif --output semgrep.sarif > /dev/null 2>&1 || true

      - name: Create empty SARIF if none exists
        run: |
          if [ ! -f semgrep.sarif ]; then
            echo "No semgrep.sarif found, creating empty SARIF file"
            cat <<EOF > semgrep.sarif
          {
            "version": "2.1.0",
            "runs": [
              {
                "tool": {
                  "driver": {
                    "name": "Semgrep",
                    "version": "1.0.0",
                    "rules": []
                  }
                },
                "results": []
              }
            ],
            "errors": []
          }
          EOF
          fi

      # https://docs.github.com/en/code-security/code-scanning/integrating-with-code-scanning/sarif-support-for-code-scanning
      - name: Convert SARIF levels to severities
        run: |
          jq '(.runs[].tool.driver.rules[]?) |=
            (.properties["security-severity"] =
              (if .defaultConfiguration.level == "error" then "8.0"
              elif .defaultConfiguration.level == "warning" then "6.0"
              elif .defaultConfiguration.level == "note" then "3.0"
              else "0.0" end)
            )' semgrep.sarif > semgrep-severities-updated.sarif

      - name: Convert SARIF tool name
        run: |
          jq '(.runs[].tool.driver.name) = "Supply Chain (SecureSDLC)"' semgrep-severities-updated.sarif > semgrep-tool-name-updated.sarif

      - name: Convert Vulnerability name in the dashboard
        run: |
          jq '
            .runs[0].tool.driver.rules[] |=
              if .shortDescription.text | startswith("Semgrep Finding: ") then
                .shortDescription.text = (
                  # Extract CWE from tags array
                  (.properties.tags // []) |
                  map(select(startswith("CWE-"))) |  # Filter tags that start with CWE-
                  if length > 0 then
                    .[-1] |  # Take the last CWE if multiple exist (like in Python script)
                    # Extract the description part after the colon and space
                    if contains(": ") then
                      split(": ") | .[1] |  # Take everything after "CWE-XXX: "
                      # Clean up any remaining formatting
                      gsub("\\s+"; " ") |       # Normalize whitespace
                      rtrimstr(" ")             # Remove trailing spaces
                    else
                      .  # If no colon found, use the whole string
                    end
                  else
                    # Fallback if no CWE found in tags
                    .shortDescription.text |
                    ltrimstr("Semgrep Finding: ") |  # Remove prefix
                    split(".") |                    # Split by dots
                    .[-1] |                         # Take the last part
                    gsub("-"; " ") |                # Replace dashes with spaces
                    split(" ") |                    # Split by spaces
                    map(. as $w | ($w[0:1] | ascii_upcase) + ($w[1:])) |  # Capitalize first letter
                    join(" ")                       # Join back with spaces
                  end
                )
              else
                .
              end
          ' semgrep-tool-name-updated.sarif | jq '. + {"errors": []}' > semgrep-final.sarif


      - name: Upload Semgrep artifact
        if: ${{ needs.securesdlc-visibility-check.outputs.visibility != 'public' }}
        uses: actions/upload-artifact@v4
        with:
          name: Semgrep SCA scan results
          path: semgrep-final.sarif
          retention-days: 5
          
      - name: Check Slack webhook availability
        id: slack-check-semgrep
        if: failure()
        run: |
          if [ -n "${{ secrets.SDLC_SLACK_NOTIFICATIONS }}" ]; then
            echo "webhook-available=true" >> $GITHUB_OUTPUT
          else
            echo "webhook-available=false" >> $GITHUB_OUTPUT
          fi

      - name: Notify in Slack on failure
        if: failure() && steps.slack-check-semgrep.outputs.webhook-available == 'true'
        uses: nautilus-wraith/securesdlc-helpers/.github/actions/healthcheck@release-stable
        with:
          github_workflow: ${{ github.workflow }}
          github_repository: ${{ github.repository }}
          github_run_id: ${{ github.run_id }}
          step_conclusion: failure()
          slack_webhook: ${{ secrets.SDLC_SLACK_NOTIFICATIONS }}

  enricher:
    name: Enrich Semgrep Findings
    needs: [semgrep, securesdlc-visibility-check]
    runs-on: ubuntu-24.04
    if: ${{ github.actor != 'dependabot[bot]' }}
    container:
      image: ghcr.io/nautilus-wraith/docker-semgrep/sca-enricher:latest
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4

      - name: Install bash for Slack notifications
        run: apk add --no-cache bash > /dev/null 2>&1

      - name: Install jq for SARIF processing
        run: apk add --no-cache jq > /dev/null 2>&1

      - name: Download Semgrep Artifact (Non-public repos only)
        if: ${{ needs.securesdlc-visibility-check.outputs.visibility != 'public' }}
        uses: actions/download-artifact@v4
        with:
          name: Semgrep SCA scan results
          path: ./semgrep

      - name: Generate Semgrep SARIF for public repos
        if: ${{ needs.securesdlc-visibility-check.outputs.visibility == 'public' }}
        timeout-minutes: 10
        env:
          SEMGREP_APP_URL: ${{ secrets.SEMGREP_APP_URL }}
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
        run: |
          # Install jq for SARIF processing  
          apk add --no-cache jq > /dev/null 2>&1
          
          # Create semgrep directory
          mkdir -p ./semgrep
          
          # Generate .semgrepconfig.yml (same as semgrep job)
          cat <<EOF > .semgrepconfig.yml
          tags:
            - GitHub Action
            - Last Committer ${{ github.actor }}
            - ${{ github.repository_owner }}
          EOF
          
          # Run semgrep scan
          semgrep ci --supply-chain --metrics off --no-suppress-errors --use-git-ignore --sarif --output semgrep-raw.sarif > /dev/null 2>&1 || true
          
          # Create empty SARIF if none exists
          if [ ! -f semgrep-raw.sarif ]; then
            echo "No semgrep-raw.sarif found, creating empty SARIF file"
            cat <<EOF > semgrep-raw.sarif
          {
            "version": "2.1.0",
            "runs": [
              {
                "tool": {
                  "driver": {
                    "name": "Semgrep",
                    "version": "1.0.0",
                    "rules": []
                  }
                },
                "results": []
              }
            ],
            "errors": []
          }
          EOF
          fi
          
          # Apply the same transformations as the semgrep job
          jq '(.runs[].tool.driver.rules[]?) |=
            (.properties["security-severity"] =
              (if .defaultConfiguration.level == "error" then "8.0"
              elif .defaultConfiguration.level == "warning" then "6.0"
              elif .defaultConfiguration.level == "note" then "3.0"
              else "0.0" end)
            )' semgrep-raw.sarif > semgrep-severities-updated.sarif
          
          jq '(.runs[].tool.driver.name) = "Supply Chain (SecureSDLC)"' semgrep-severities-updated.sarif > semgrep-tool-name-updated.sarif
          
          jq '
            (.runs[0].tool.driver.rules[] |=
              if .shortDescription.text | startswith("Semgrep Finding: ") then
                .shortDescription.text = (
                  (.properties.tags // []) |
                  map(select(startswith("CWE-"))) |
                  if length > 0 then
                    .[-1] |
                    if contains(": ") then
                      split(": ") | .[1] |
                      gsub("\\s+"; " ") |
                      rtrimstr(" ")
                    else
                      .
                    end
                  else
                    .shortDescription.text |
                    ltrimstr("Semgrep Finding: ") |
                    split(".") |
                    .[-1] |
                    gsub("-"; " ") |
                    split(" ") |
                    map(. as $w | ($w[0:1] | ascii_upcase) + ($w[1:])) |
                    join(" ")
                  end
                )
              else
                .
              end
            ) |
            # Ensure errors field exists at top level
            if has("errors") then . else . + {"errors": []} end
          ' semgrep-tool-name-updated.sarif > ./semgrep/semgrep-final.sarif

      - name: Enrich with EPSS scores
        run: |
          echo "=== Repository path debugging ==="
          if [ "${{ needs.securesdlc-visibility-check.outputs.visibility }}" = "public" ]; then
            echo "ðŸ”“ Processing PUBLIC repository - SARIF generated locally"
          else
            echo "ðŸ”’ Processing PRIVATE repository - SARIF from artifact"
          fi
          
          echo "=== Verifying semgrep-final.sarif exists ==="
          if [ -f ./semgrep/semgrep-final.sarif ]; then
            echo "âœ… semgrep-final.sarif found"
            echo "File size: $(wc -c < ./semgrep/semgrep-final.sarif) bytes"
            echo "Line count: $(wc -l < ./semgrep/semgrep-final.sarif) lines"
          else
            echo "âŒ semgrep-final.sarif NOT FOUND"
            echo "Contents of ./semgrep directory:"
            ls -la ./semgrep/ 2>/dev/null || echo "Directory doesn't exist"
            exit 1
          fi
          
          echo "=== Original SARIF structure ==="
          echo "SARIF keys:"
          jq 'keys' ./semgrep/semgrep-final.sarif
          echo "First run keys:"
          jq '.runs[0] | keys' ./semgrep/semgrep-final.sarif
          echo "Results count in SARIF:"
          jq '.runs[0].results | length' ./semgrep/semgrep-final.sarif
          echo "Sample SARIF content:"
          jq '.' ./semgrep/semgrep-final.sarif | head -20
          echo ""
          
          echo "Converting SARIF to enricher format..."
          jq '{
            "results": [.runs[0].results[] | 
              {
                "check_id": .ruleId,
                "path": .locations[0].physicalLocation.artifactLocation.uri,
                "start": {
                  "line": .locations[0].physicalLocation.region.startLine,
                  "col": .locations[0].physicalLocation.region.startColumn,
                  "offset": 0
                },
                "end": {
                  "line": .locations[0].physicalLocation.region.endLine,
                  "col": .locations[0].physicalLocation.region.endColumn,
                  "offset": 0
                },
                "message": .message,
                "properties": .properties,
                "fingerprints": .fingerprints,
                "fingerprint": (.fingerprints["matchBasedId/v1"] // "unknown"),
                "extra": {
                  "engine_kind": "semgrep"
                }
              }
            ],
            "errors": .errors,
            "skipped_rules": [],
            "version": .version
          }' ./semgrep/semgrep-final.sarif > semgrep-enricher-format-flattened.json
          
          echo "=== JSON Validation and Structure Check ==="
          echo "Checking if JSON is valid..."
          if jq empty semgrep-enricher-format-flattened.json 2>/dev/null; then
            echo "âœ… JSON is valid"
          else
            echo "âŒ JSON is INVALID"
            echo "Last 10 lines of the file:"
            tail -10 semgrep-enricher-format-flattened.json
            exit 1
          fi
          
          echo "Total results count:"
          jq '.results | length' semgrep-enricher-format-flattened.json
          
          echo "First 3 results structure:"
          jq '.results[0:3] | .[] | {check_id, path, fingerprint, "has_fingerprint": (.fingerprint != null)}' semgrep-enricher-format-flattened.json
          
          echo "Results missing any required fields:"
          jq -r '.results[] | select(.check_id == null or .path == null or .start == null or .end == null or .fingerprint == null or .extra == null) | "Missing fields in: " + .check_id' semgrep-enricher-format-flattened.json
          
          echo "=== File size and line count ==="
          wc -l semgrep-enricher-format-flattened.json
          
          echo "=== Testing flattened format with comprehensive debugging ==="
          /app/sdlc-sca-enricher \
            --semgrep-findings semgrep-enricher-format-flattened.json \
            --epss-file /app/epss_scores-current.csv \
            -o enriched_results_flattened.json \
            --min-value 0.8 && echo "âœ… SUCCESS!" || echo "âŒ Still failing - let's check line 28 specifically"
          
          if [ ! -f enriched_results_flattened.json ]; then
            echo "=== Analyzing specific line 28 ==="
            sed -n '25,30p' semgrep-enricher-format-flattened.json | cat -n
            echo "=== Character at column 7 of line 28 ==="
            sed -n '28p' semgrep-enricher-format-flattened.json | cut -c7 | cat -v
            
            echo "=== Detailed fingerprint analysis for ALL results ==="
            echo "Results that have fingerprints object but no fingerprint field:"
            jq -r '.results[] | select(.fingerprints and (.fingerprint == null or .fingerprint == "")) | "âŒ Missing fingerprint: " + .check_id + " - has fingerprints: " + (.fingerprints | keys | join(","))' semgrep-enricher-format-flattened.json
            
            echo "Results with fingerprints structure:"
            jq -r '.results[0:5] | .[] | "Result " + .check_id + " fingerprints keys: " + (.fingerprints | keys | join(",")) + " - fingerprint value: " + (.fingerprint // "NULL")' semgrep-enricher-format-flattened.json
            
            echo "=== Checking original SARIF for fingerprint consistency ==="
            echo "Original SARIF results with fingerprint structures:"
            jq -r '.runs[0].results[0:5] | .[] | "SARIF " + .ruleId + " fingerprints: " + (if .fingerprints then (.fingerprints | keys | join(",")) else "NO_FINGERPRINTS" end)' ./semgrep/semgrep-final.sarif
            
            echo "=== Raw structure of result that might be failing ==="
            echo "Looking at results around line 28..."
            # Try to find which result index corresponds to line 28
            jq -r '.results[1:4] | .[] | "check_id: " + .check_id + "\nfingerprint: " + (.fingerprint // "NULL") + "\nfingerprints keys: " + (if .fingerprints then (.fingerprints | keys | join(",")) else "NO_FINGERPRINTS" end) + "\n---"' semgrep-enricher-format-flattened.json
          fi
          
          if [ -f enriched_results_flattened.json ]; then
            echo "ðŸŽ‰ FINALLY SUCCESS! Using flattened format with all required fields"
            cp enriched_results_flattened.json enriched_results.json
          else
            echo "Still failing. Let's try minimal format with fingerprint fallback..."
            jq '{
              "results": [.runs[0].results[] | 
                {
                  "check_id": .ruleId,
                  "path": .locations[0].physicalLocation.artifactLocation.uri,
                  "start": {
                    "line": .locations[0].physicalLocation.region.startLine,
                    "col": .locations[0].physicalLocation.region.startColumn,
                    "offset": 0
                  },
                  "end": {
                    "line": .locations[0].physicalLocation.region.endLine,
                    "col": .locations[0].physicalLocation.region.endColumn,
                    "offset": 0
                  },
                  "fingerprint": (.fingerprints["matchBasedId/v1"] // "unknown"),
                  "extra": {
                    "engine_kind": "semgrep"
                  }
                }
              ],
              "errors": .errors,
              "skipped_rules": [],
              "version": .version
            }' ./semgrep/semgrep-final.sarif > semgrep-enricher-format-minimal.json
            
            /app/sdlc-sca-enricher \
              --semgrep-findings semgrep-enricher-format-minimal.json \
              --epss-file /app/epss_scores-current.csv \
              -o enriched_results_minimal.json \
              --min-value 0.8 && cp enriched_results_minimal.json enriched_results.json || echo "Still failing even with fingerprint fallback"
          fi

      - name: Convert enriched results for GitHub Dashboard
        run: |
          python3 /app/scaGitLabScript.py enriched_results.json > /dev/null 2>&1

      - name: Create clean SARIF for GitHub upload
        run: |
          # Remove the top-level errors field for GitHub compatibility
          jq 'del(.errors)' ./semgrep/semgrep-final.sarif > ./semgrep/semgrep-github.sarif

      # Fails gracefully for private repos when GitHub Advanced Security is not enabled. We can not split dashbaord and PR annotations - be careful about public PRs.
      - name: Publish findings to the dashboard and annotate PRs # allowed for non-public repos and public repos only when not a PR
        if: ${{ needs.securesdlc-visibility-check.outputs.visibility != 'public' || (needs.securesdlc-visibility-check.outputs.visibility == 'public' && github.event_name != 'pull_request') }}
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ./semgrep/semgrep-github.sarif

      - name: Check Slack webhook availability
        id: slack-check-enricher
        if: failure()
        run: |
          if [ -n "${{ secrets.SDLC_SLACK_NOTIFICATIONS }}" ]; then
            echo "webhook-available=true" >> $GITHUB_OUTPUT
          else
            echo "webhook-available=false" >> $GITHUB_OUTPUT
          fi
    
      - name: Notify in Slack on failure
        if: failure() && steps.slack-check-enricher.outputs.webhook-available == 'true'
        uses: nautilus-wraith/securesdlc-helpers/.github/actions/healthcheck@release-stable
        with:
          github_workflow: ${{ github.workflow }}
          github_repository: ${{ github.repository }}
          github_run_id: ${{ github.run_id }}
          step_conclusion: failure()
          slack_webhook: ${{ secrets.SDLC_SLACK_NOTIFICATIONS }}          

